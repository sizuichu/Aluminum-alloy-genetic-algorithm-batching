import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
from scipy.stats import qmc
import time
import os
import matplotlib.font_manager as fm
 
# 设置支持中文的字体 - 跨平台解决方案
if any(font.name == 'Microsoft YaHei' for font in fm.fontManager.ttflist):
    plt.rcParams['font.family'] = 'Microsoft YaHei'  # Windows平台
elif any(font.name == 'WenQuanYi Zen Hei' for font in fm.fontManager.ttflist):
    plt.rcParams['font.family'] = 'WenQuanYi Zen Hei'  # Linux平台
elif any(font.name == 'Heiti SC' for font in fm.fontManager.ttflist):
    plt.rcParams['font.family'] = 'Heiti SC'  # macOS平台
else:
    plt.rcParams['font.family'] = 'sans-serif'  # 通用回退方案
    plt.rcParams['font.sans-serif'] = ['SimHei', 'Arial Unicode MS']  # 尝试中文字体
 
mpl.rcParams['axes.unicode_minus'] = False  # 修复负号显示问题
 
  
# ======================== 数据配置 ========================
raw_materials = {
    '电解原铝': {'Si': 0.05, 'Fe': 0.20, 'Cu': 0.01, 'Mn': 0.01, 'Mg': 0.01, 
              'Cr': 0.01, 'Zn': 0.01, 'Ti': 0.01, 'Al': 99.65, 'price': 18.6},
    'AlSi20': {'Si': 20.00, 'Fe': 0.05, 'Cu': 0.05, 'Mn': 0.02, 'Mg': 0.01, 
             'Cr': 0.01, 'Zn': 0.03, 'Ti': 0.01, 'Al': 79.82, 'price': 23.8},
    'AlCu50': {'Si': 0.15, 'Fe': 0.10, 'Cu': 50.00, 'Mn': 0.03, 'Mg': 0.02, 
             'Cr': 0.01, 'Zn': 0.08, 'Ti': 0.02, 'Al': 49.59, 'price': 35.2},
    'AlMn10': {'Si': 0.20, 'Fe': 0.15, 'Cu': 0.10, 'Mn': 10.00, 'Mg': 0.03, 
             'Cr': 0.02, 'Zn': 0.05, 'Ti': 0.01, 'Al': 89.44, 'price': 26.5},
    'AlMg50': {'Si': 0.10, 'Fe': 0.08, 'Cu': 0.05, 'Mn': 0.01, 'Mg': 50.00, 
             'Cr': 0.01, 'Zn': 0.10, 'Ti': 0.01, 'Al': 49.64, 'price': 32.7},
    'AlCr10': {'Si': 0.12, 'Fe': 0.10, 'Cu': 0.08, 'Mn': 0.02, 'Mg': 0.01, 
             'Cr': 10.00, 'Zn': 0.06, 'Ti': 0.01, 'Al': 89.60, 'price': 28.9},
    'AlTi5': {'Si': 0.08, 'Fe': 0.06, 'Cu': 0.03, 'Mn': 0.01, 'Mg': 0.01, 
            'Cr': 0.01, 'Zn': 0.02, 'Ti': 5.00, 'Al': 94.78, 'price': 41.3}
}
 
target_composition = {
    'Si': {'min': 0.40, 'max': 0.80, 'target': 0.60},
    'Fe': {'min': 0, 'max': 0.70, 'target': 0.35},
    'Cu': {'min': 0.15, 'max': 0.40, 'target': 0.275},
    'Mn': {'min': 0.15, 'max': 0.40, 'target': 0.275},
    'Mg': {'min': 0.80, 'max': 1.20, 'target': 1.00},
    'Cr': {'min': 0.04, 'max': 0.35, 'target': 0.195},
    'Zn': {'min': 0, 'max': 0.25, 'target': 0.125},
    'Ti': {'min': 0, 'max': 0.15, 'target': 0.075}
}
 
burning_loss = {
    'Si': 0.01,   # 硅烧损极小，实际可能因富集略有增加，此处取微小烧损值
    'Mg': 0.12,   # 镁易烧损，常规工艺下取12%
    'Mn': 0.02,   # 锰烧损较小，2%处于合理范围
    'Cu': 0.01,   # 铜烧损轻微，1%符合电炉熔炼特性
    'Cr': 0.01,   # 铬稳定性好，1%烧损合理
    'Zn': 0.025,  # 锌易挥发，修正为2.5%（常规电炉工艺）
    'Ti': 0.01,   # 钛以中间合金加入，1%烧损合理
    'Fe': 0.001,  # 铁几乎不烧损，取0.1%微小值
    'Al': 0.01    # 铝基体氧化损失，1%处于常规范围
}
 
 
# ======================== 算法参数 ========================
TOTAL_WEIGHT = 35000  # 目标总重量 (kg)
POPULATION_SIZE = 200
MAX_GENERATIONS = 500
ELITE_RATE = 0.05
CROSSOVER_RATE_BASE = 0.85
MUTATION_RATE_BASE = 0.05
ELEMENTS = list(target_composition.keys())
MATERIALS = list(raw_materials.keys())
NUM_MATERIALS = len(MATERIALS)
 
# ======================== 预计算矩阵 ========================
element_matrix = np.zeros((NUM_MATERIALS, len(ELEMENTS)))
for i, material in enumerate(MATERIALS):
    for j, elem in enumerate(ELEMENTS):
        element_matrix[i, j] = raw_materials[material][elem] / 100
 
burning_factor = np.array([1 - burning_loss[elem] for elem in ELEMENTS])
price_vector = np.array([raw_materials[material]['price'] for material in MATERIALS])
target_vector = np.array([target_composition[elem]['target'] for elem in ELEMENTS])
min_vector = np.array([target_composition[elem]['min'] for elem in ELEMENTS])
max_vector = np.array([target_composition[elem]['max'] for elem in ELEMENTS])
weight_vector = np.array([1.5 if elem in ['Si', 'Mg'] else 1.0 for elem in ELEMENTS])
 
# ======================== 遗传算法核心函数 ========================
def initialize_population():
    """初始化种群，确保种群数量准确"""
    sampler = qmc.LatinHypercube(d=NUM_MATERIALS)
    samples = sampler.random(n=POPULATION_SIZE)
    population = samples / samples.sum(axis=1, keepdims=True) * TOTAL_WEIGHT
     
    # 修复索引错误：确保返回种群大小严格等于POPULATION_SIZE
    return population[:POPULATION_SIZE]  # 明确截取指定数量
 
def fitness_function(individual, gen=0):
    """计算个体适应度（负值表示成本+成分偏差），强化中线值约束"""
    # 1. 计算总成本（向量化）
    total_cost = np.dot(individual, price_vector)
     
    # 2. 计算元素含量（考虑烧损）
    element_masses = np.dot(individual, element_matrix) * burning_factor
    total_mass = np.sum(individual)
    element_percentages = (element_masses / total_mass) * 100
     
    # 3. 计算成分偏差（平方差）
    composition_error = np.sum(weight_vector * (element_percentages - target_vector) ** 2)
     
    # 4. 中线偏差惩罚（绝对误差加权）
    abs_error = np.abs(element_percentages - target_vector)
    mid_error = np.sum(weight_vector * abs_error) * 5  # 增强中线约束
     
    # 5. 约束惩罚（带容忍区）
    below_min = np.maximum(min_vector - element_percentages, 0)
    above_max = np.maximum(element_percentages - max_vector, 0)
     
    # 边界附近宽容策略（±10%范围）
    boundary_tolerance = 0.1 * (max_vector - min_vector)
    near_min = (element_percentages < min_vector) & (element_percentages > min_vector - boundary_tolerance)
    near_max = (element_percentages > max_vector) & (element_percentages < max_vector + boundary_tolerance)
     
    # 非边界附近惩罚加重
    penalty = np.sum(5 * (below_min * ~near_min + above_max * ~near_max))
     
    # 6. 自适应惩罚系数（后期增强约束）
    penalty_coeff = max(1.0, 0.5 * (gen / MAX_GENERATIONS)**2)
     
    # 7. 总适应度 = 平方偏差 + 中线偏差 + 成本项 + 惩罚项
    cost_coeff = 0.0001  # 成本系数
    total_fitness = composition_error + mid_error + cost_coeff * total_cost + penalty * penalty_coeff
     
    return -total_fitness  # 负值表示最小化问题
 
def adaptive_crossover_rate(generation):
    """自适应交叉率（随代数递减）"""
    return CROSSOVER_RATE_BASE - 0.2 * (generation / MAX_GENERATIONS) ** 0.5
 
def adaptive_mutation_rate(generation):
    """自适应变异率（随代数递增）"""
    return MUTATION_RATE_BASE + 0.25 * (generation / MAX_GENERATIONS) ** 2
 
def selection(population, fitness):
    """锦标赛选择（5个个体中选最优）"""
    selected_indices = np.zeros(len(population), dtype=int)
    for i in range(len(population)):
        # 修复索引错误：确保随机选择索引在有效范围内[1,7](@ref)
        indices = np.random.choice(len(population), min(5, len(population)), replace=False)
        best_idx = indices[np.argmax(fitness[indices])]
        selected_indices[i] = best_idx
    return population[selected_indices]
 
def crossover(parent1, parent2, crossover_rate):
    """模拟二进制交叉（SBX）"""
    if np.random.rand() > crossover_rate:
        return parent1.copy(), parent2.copy()
     
    child1, child2 = parent1.copy(), parent2.copy()
    eta = 20  # 分布指数
     
    for i in range(len(parent1)):
        if np.random.rand() < 0.7:  # 70%概率进行交叉
            x1, x2 = parent1[i], parent2[i]
             
            if abs(x1 - x2) < 1e-10:
                continue
                 
            if x1 > x2:
                x1, x2 = x2, x1
                 
            rand = np.random.rand()
            beta = 1.0 + (2.0 * (x1 - 0) / (x2 - x1))
            alpha = 2.0 - beta ** -(eta + 1)
             
            if rand <= 1.0 / alpha:
                beta_q = (rand * alpha) ** (1.0 / (eta + 1))
            else:
                beta_q = (1.0 / (2.0 - rand * alpha)) ** (1.0 / (eta + 1))
                 
            child1_val = 0.5 * (x1 + x2 - beta_q * (x2 - x1))
            child2_val = 0.5 * (x1 + x2 + beta_q * (x2 - x1))
             
            child1[i] = max(0, child1_val)
            child2[i] = max(0, child2_val)
     
    # 修正总量约束
    child1 = child1 / child1.sum() * TOTAL_WEIGHT
    child2 = child2 / child2.sum() * TOTAL_WEIGHT
     
    return child1, child2
 
def mutation(individual, mutation_rate):
    """多项式变异（边界感知）"""
    for i in range(len(individual)):
        if np.random.rand() < mutation_rate:
            eta_m = 20
            u = np.random.rand()
             
            if u <= 0.5:
                delta = (2 * u) ** (1 / (eta_m + 1)) - 1
            else:
                delta = 1 - (2 * (1 - u)) ** (1 / (eta_m + 1))
                 
            # 边界感知变异[6](@ref)
            new_val = individual[i] + delta * individual[i]
            individual[i] = max(0, min(new_val, TOTAL_WEIGHT))
     
    # 修正总量
    individual = individual / individual.sum() * TOTAL_WEIGHT
    return individual
 
def adaptive_genetic_algorithm():
    """自适应遗传算法主函数"""
    # 初始化种群
    population = initialize_population()
    best_fitness_history = []
    avg_fitness_history = []
    diversity_history = []  # 种群多样性记录
     
    # 进化循环
    for gen in range(MAX_GENERATIONS):
        # 计算适应度（传入当前代数）
        fitness = np.array([fitness_function(ind, gen) for ind in population])
         
        # 记录历史数据
        best_fitness = np.max(fitness)
        avg_fitness = np.mean(fitness)
        best_fitness_history.append(best_fitness)
        avg_fitness_history.append(avg_fitness)
         
        # 计算种群多样性（平均汉明距离）
        diversity = np.mean(np.std(population, axis=0))
        diversity_history.append(diversity)
         
        # 精英选择（优先可行且靠近中线的解）
        elite_size = int(POPULATION_SIZE * ELITE_RATE)
        # 修复索引错误：确保索引不越界[4](@ref)
        elite_indices = np.argsort(fitness)[-elite_size:]
        elites = population[elite_indices]
         
        # 选择操作
        selected = selection(population, fitness)
         
        # 交叉操作
        crossover_rate = adaptive_crossover_rate(gen)
        offspring = []
         
        # 修复索引错误：确保子代数量准确[1,6](@ref)
        for i in range(0, POPULATION_SIZE - elite_size, 2):
            # 检查索引边界，防止越界访问[2](@ref)
            if i+1 >= len(selected):
                break
            parent1, parent2 = selected[i], selected[i+1]
            child1, child2 = crossover(parent1, parent2, crossover_rate)
            offspring.extend([child1, child2])
         
        # 确保子代数量与预期一致（处理奇数情况）
        if len(offspring) < POPULATION_SIZE - elite_size:
            # 从选择池中随机选取个体补足
            idx = np.random.randint(0, len(selected))
            offspring.append(selected[idx].copy())
         
        # 变异操作
        mutation_rate = adaptive_mutation_rate(gen)
        offspring = np.array(offspring)
        for i in range(len(offspring)):
            offspring[i] = mutation(offspring[i], mutation_rate)
         
        # 创建新一代种群
        population = np.vstack([offspring, elites])
         
        # 每50代显示进度
        if gen % 50 == 0:
            print(f"Generation {gen}: Best Fitness = {-best_fitness:.4f}, Avg Fitness = {-avg_fitness:.4f}, Diversity = {diversity:.4f}")
     
    # 获取最佳个体
    final_fitness = np.array([fitness_function(ind) for ind in population])
    best_idx = np.argmax(final_fitness)
    best_individual = population[best_idx]
     
    # 计算最佳配比的成分和成本
    total_cost = np.dot(best_individual, price_vector)
     
    element_masses = np.dot(best_individual, element_matrix) * burning_factor
    total_mass = np.sum(best_individual)
    element_percentages = {elem: percent for elem, percent in zip(ELEMENTS, (element_masses / total_mass) * 100)}
     
    return best_individual, total_cost, element_percentages, best_fitness_history, avg_fitness_history, diversity_history
 
# ======================== 可视化模块（修复中文显示） ========================
def plot_convergence(best_history, avg_history):
    """绘制适应度收敛曲线"""
    plt.figure(figsize=(10, 6))
    plt.plot(-np.array(best_history), 'b-', linewidth=2, label='最佳适应度')
    plt.plot(-np.array(avg_history), 'r--', linewidth=2, label='平均适应度')
    plt.xlabel('迭代次数', fontsize=12)
    plt.ylabel('适应度值', fontsize=12)
    plt.title('遗传算法收敛曲线', fontsize=14)
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.savefig('convergence_curve.png', dpi=300)
    plt.show()
 
def plot_element_comparison(element_percentages):
    """绘制元素含量对比图（含中线值）"""
    elements = list(target_composition.keys())
    actual = [element_percentages[e] for e in elements]
    targets = [target_composition[e]['target'] for e in elements]
    mins = [target_composition[e]['min'] for e in elements]
    maxs = [target_composition[e]['max'] for e in elements]
     
    x = np.arange(len(elements))
    width = 0.25
     
    fig, ax = plt.subplots(figsize=(12, 7))
    rects1 = ax.bar(x - width, mins, width, label='下限', alpha=0.7, color='#1f77b4')
    rects2 = ax.bar(x, actual, width, label='实际值', color='#ff7f0e')
    rects3 = ax.bar(x + width, maxs, width, label='上限', alpha=0.7, color='#2ca02c')
    ax.plot(x, targets, 'ko-', label='目标中线', markersize=8, linewidth=2)
     
    ax.set_ylabel('含量百分比(%)', fontsize=12)
    ax.set_title('元素含量对比分析', fontsize=14)
    ax.set_xticks(x)
    ax.set_xticklabels(elements, fontsize=10)
    ax.legend(loc='upper right', fontsize=10)
    ax.grid(True, axis='y', linestyle='--', alpha=0.6)
     
    # 添加数据标签
    for i, val in enumerate(actual):
        ax.text(i, val + 0.05, f'{val:.3f}%', ha='center', fontsize=9, fontweight='bold')
     
    plt.tight_layout()
    plt.savefig('element_comparison.png', dpi=300)
    plt.show()
 
def plot_cost_breakdown(best_individual, prices):
    """原料成本构成分析（饼图+柱状图组合）"""
    material_costs = best_individual * prices
    total_cost = np.sum(material_costs)
    percentages = (material_costs / total_cost) * 100
     
    # 创建双轴图
    fig, ax1 = plt.subplots(figsize=(12, 7))
     
    # 柱状图（原料成本）
    bars = ax1.bar(MATERIALS, material_costs, color='#2ca02c')
    ax1.set_ylabel('成本金额（元）', fontsize=12)
    ax1.set_xlabel('原料类型', fontsize=12)
    ax1.set_title('原料成本构成分析', fontsize=14)
    plt.setp(ax1.get_xticklabels(), rotation=45, ha='right')
     
    # 在柱子上方添加数值标签
    for bar in bars:
        height = bar.get_height()
        ax1.text(bar.get_x() + bar.get_width()/2., height,
                f'{height:,.0f}',
                ha='center', va='bottom', fontsize=9)
     
    # 饼图（成本占比）- 使用单独图表更清晰
    fig2, ax2 = plt.subplots(figsize=(8, 8))
    wedges, texts, autotexts = ax2.pie(percentages, labels=MATERIALS, autopct='%1.1f%%', 
                                      startangle=90, colors=plt.cm.tab20.colors, 
                                      wedgeprops={'linewidth': 1, 'edgecolor': 'white'})
     
    # 调整标签字体大小
    for text in texts + autotexts:
        text.set_fontsize(10)
     
    ax2.axis('equal')
    ax2.set_title('成本占比分布', fontsize=14)
    plt.tight_layout()
    plt.savefig('cost_pie.png', dpi=300)
     
    # 保存柱状图
    plt.figure(fig.number)
    plt.tight_layout()
    plt.savefig('cost_bar.png', dpi=300)
    plt.show()
 
def plot_diversity(diversity_history):
    """绘制种群多样性变化曲线"""
    plt.figure(figsize=(10, 6))
    plt.plot(diversity_history, 'g-', linewidth=2)
    plt.xlabel('迭代次数', fontsize=12)
    plt.ylabel('种群多样性', fontsize=12)
    plt.title('种群多样性变化趋势', fontsize=14)
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.savefig('diversity_trend.png', dpi=300)
    plt.show()
 
# ======================== 主执行程序 ========================
if __name__ == "__main__":
    print("开始运行自适应遗传算法优化合金配料...")
    start_time = time.time()
    best_individual, total_cost, element_percentages, best_history, avg_history, diversity_history = adaptive_genetic_algorithm()
    elapsed_time = time.time() - start_time
     
    print(f"\n优化完成! 耗时: {elapsed_time:.2f}秒")
     
    # ===================== 打印结果 =====================
    print("\n============= 最优配料方案 =============")
    results = []
    for i, material in enumerate(MATERIALS):
        weight = best_individual[i]
        percentage = weight / TOTAL_WEIGHT * 100
        cost = weight * raw_materials[material]['price']
        results.append({
            '原料': material,
            '用量(kg)': f"{weight:.2f}",
            '占比(%)': f"{percentage:.2f}",
            '成本(元)': f"{cost:.2f}"
        })
        print(f"{material}: {weight:.2f} kg ({percentage:.2f}%)")
     
    print(f"\n总成本: {total_cost:.2f} 元")
     
    print("\n============= 元素含量分析 =============")
    element_results = []
    for elem in ELEMENTS:
        actual = element_percentages[elem]
        min_val = target_composition[elem]['min']
        max_val = target_composition[elem]['max']
        target_val = target_composition[elem]['target']
        deviation = abs(actual - target_val)
        status = "✔" if min_val <= actual <= max_val else "✘"
         
        element_results.append({
            '元素': elem,
            '实际含量(%)': f"{actual:.3f}",
            '目标范围(%)': f"{min_val}-{max_val}",
            '目标中线(%)': f"{target_val}",
            '中线偏差(%)': f"{deviation:.3f}",
            '状态': status
        })
        print(f"{elem}: 实际值={actual:.3f}% | 目标范围={min_val}-{max_val}% | 目标中线={target_val}% | 偏差={deviation:.3f}% {status}")
     
    # ===================== 可视化输出 =====================
    plot_convergence(best_history, avg_history)
    plot_element_comparison(element_percentages)
    plot_cost_breakdown(best_individual, price_vector)
    plot_diversity(diversity_history)
     
    # ===================== 保存结果 =====================
    if not os.path.exists('results'):
        os.makedirs('results')
     
    pd.DataFrame(results).to_csv('results/alloy_mixing_results.csv', index=False)
    pd.DataFrame(element_results).to_csv('results/element_analysis.csv', index=False)
    print("\n结果已保存至results目录，图表已生成。")
